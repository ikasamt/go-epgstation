// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny

package pkg

import (
	"reflect"
	"sort"

	"github.com/ikasamt/goslicer/typeslicer"
)

type Channels []Channel

// First is ..
func (anythings Channels) First() (Channel, bool) {
	if len(anythings) == 0 {
		return Channel{}, false
	}
	return anythings[0], true
}

// Where is ..
func (anythings Channels) Where(f func(anything Channel) bool) (result Channels) {
	for _, a := range anythings {
		if f(a) {
			result = append(result, a)
		}
	}
	return
}

// Count is ..
func (anythings Channels) Count() (counter int) {
	return len(anythings)
}

// CountIf is ..
func (anythings Channels) CountIf(f func(anything Channel) bool) (counter int) {
	for _, a := range anythings {
		if f(a) {
			counter++
		}
	}
	return
}

// Select is ..
func (anythings Channels) Select(fieldName string) (result typeslicer.InterfaceSlice) {
	for _, a := range anythings {
		i := reflect.ValueOf(a).FieldByName(fieldName).Interface()
		result = append(result, i)
	}
	return
}

// SortBy is ..
func (anythings Channels) SortBy(sortFunc func(Channel, Channel) bool) (result Channels) {
	f := func(i, j int) bool {
		a := anythings[i]
		b := anythings[j]
		return sortFunc(a, b)
	}

	tmp := make(Channels, len(anythings))
	copy(tmp, anythings)
	sort.Slice(tmp, f)
	return tmp
}

// DistinctBy is ..
func (anythings Channels) DistinctBy(f func(anything Channel) interface{}) (result Channels) {
	tmp := map[interface{}]Channel{}
	for _, a := range anythings {
		tmp[f(a)] = a
	}
	for _, t := range tmp {
		result = append(result, t)
	}
	return
}

func (anythings Channels) Mapper(f func(anything Channel) Channel) (result Channels) {
	for _, a := range anythings {
		result = append(result, f(a))
	}
	return
}

type Encodeds []Encoded

// First is ..
func (anythings Encodeds) First() (Encoded, bool) {
	if len(anythings) == 0 {
		return Encoded{}, false
	}
	return anythings[0], true
}

// Where is ..
func (anythings Encodeds) Where(f func(anything Encoded) bool) (result Encodeds) {
	for _, a := range anythings {
		if f(a) {
			result = append(result, a)
		}
	}
	return
}

// Count is ..
func (anythings Encodeds) Count() (counter int) {
	return len(anythings)
}

// CountIf is ..
func (anythings Encodeds) CountIf(f func(anything Encoded) bool) (counter int) {
	for _, a := range anythings {
		if f(a) {
			counter++
		}
	}
	return
}

// Select is ..
func (anythings Encodeds) Select(fieldName string) (result typeslicer.InterfaceSlice) {
	for _, a := range anythings {
		i := reflect.ValueOf(a).FieldByName(fieldName).Interface()
		result = append(result, i)
	}
	return
}

// SortBy is ..
func (anythings Encodeds) SortBy(sortFunc func(Encoded, Encoded) bool) (result Encodeds) {
	f := func(i, j int) bool {
		a := anythings[i]
		b := anythings[j]
		return sortFunc(a, b)
	}

	tmp := make(Encodeds, len(anythings))
	copy(tmp, anythings)
	sort.Slice(tmp, f)
	return tmp
}

// DistinctBy is ..
func (anythings Encodeds) DistinctBy(f func(anything Encoded) interface{}) (result Encodeds) {
	tmp := map[interface{}]Encoded{}
	for _, a := range anythings {
		tmp[f(a)] = a
	}
	for _, t := range tmp {
		result = append(result, t)
	}
	return
}

func (anythings Encodeds) Mapper(f func(anything Encoded) Encoded) (result Encodeds) {
	for _, a := range anythings {
		result = append(result, f(a))
	}
	return
}

type EncodedPrograms []EncodedProgram

// First is ..
func (anythings EncodedPrograms) First() (EncodedProgram, bool) {
	if len(anythings) == 0 {
		return EncodedProgram{}, false
	}
	return anythings[0], true
}

// Where is ..
func (anythings EncodedPrograms) Where(f func(anything EncodedProgram) bool) (result EncodedPrograms) {
	for _, a := range anythings {
		if f(a) {
			result = append(result, a)
		}
	}
	return
}

// Count is ..
func (anythings EncodedPrograms) Count() (counter int) {
	return len(anythings)
}

// CountIf is ..
func (anythings EncodedPrograms) CountIf(f func(anything EncodedProgram) bool) (counter int) {
	for _, a := range anythings {
		if f(a) {
			counter++
		}
	}
	return
}

// Select is ..
func (anythings EncodedPrograms) Select(fieldName string) (result typeslicer.InterfaceSlice) {
	for _, a := range anythings {
		i := reflect.ValueOf(a).FieldByName(fieldName).Interface()
		result = append(result, i)
	}
	return
}

// SortBy is ..
func (anythings EncodedPrograms) SortBy(sortFunc func(EncodedProgram, EncodedProgram) bool) (result EncodedPrograms) {
	f := func(i, j int) bool {
		a := anythings[i]
		b := anythings[j]
		return sortFunc(a, b)
	}

	tmp := make(EncodedPrograms, len(anythings))
	copy(tmp, anythings)
	sort.Slice(tmp, f)
	return tmp
}

// DistinctBy is ..
func (anythings EncodedPrograms) DistinctBy(f func(anything EncodedProgram) interface{}) (result EncodedPrograms) {
	tmp := map[interface{}]EncodedProgram{}
	for _, a := range anythings {
		tmp[f(a)] = a
	}
	for _, t := range tmp {
		result = append(result, t)
	}
	return
}

func (anythings EncodedPrograms) Mapper(f func(anything EncodedProgram) EncodedProgram) (result EncodedPrograms) {
	for _, a := range anythings {
		result = append(result, f(a))
	}
	return
}

type Videos []Video

// First is ..
func (anythings Videos) First() (Video, bool) {
	if len(anythings) == 0 {
		return Video{}, false
	}
	return anythings[0], true
}

// Where is ..
func (anythings Videos) Where(f func(anything Video) bool) (result Videos) {
	for _, a := range anythings {
		if f(a) {
			result = append(result, a)
		}
	}
	return
}

// Count is ..
func (anythings Videos) Count() (counter int) {
	return len(anythings)
}

// CountIf is ..
func (anythings Videos) CountIf(f func(anything Video) bool) (counter int) {
	for _, a := range anythings {
		if f(a) {
			counter++
		}
	}
	return
}

// Select is ..
func (anythings Videos) Select(fieldName string) (result typeslicer.InterfaceSlice) {
	for _, a := range anythings {
		i := reflect.ValueOf(a).FieldByName(fieldName).Interface()
		result = append(result, i)
	}
	return
}

// SortBy is ..
func (anythings Videos) SortBy(sortFunc func(Video, Video) bool) (result Videos) {
	f := func(i, j int) bool {
		a := anythings[i]
		b := anythings[j]
		return sortFunc(a, b)
	}

	tmp := make(Videos, len(anythings))
	copy(tmp, anythings)
	sort.Slice(tmp, f)
	return tmp
}

// DistinctBy is ..
func (anythings Videos) DistinctBy(f func(anything Video) interface{}) (result Videos) {
	tmp := map[interface{}]Video{}
	for _, a := range anythings {
		tmp[f(a)] = a
	}
	for _, t := range tmp {
		result = append(result, t)
	}
	return
}

func (anythings Videos) Mapper(f func(anything Video) Video) (result Videos) {
	for _, a := range anythings {
		result = append(result, f(a))
	}
	return
}
